%Get size of program
actionSize = length(Cost(1,:));
stateSize = length(CurrPolicy);

%Policy Iteration
LastPolicy = NaN(1,stateSize);
LastCost = 0;
CurrCost = 0;
iterate = 1;
while (iterate)
    if (verbose)
        disp(CurrPolicy);
    end
    LastPolicy = CurrPolicy;
    LastCost = CurrCost;
    
    %Value Determination
    policyProb = [];
    policyCost = [];
    for i = 1:stateSize
        policyProb = [policyProb; TransProb(i,(CurrPolicy(i)*stateSize+1):((CurrPolicy(i)+1)*stateSize))];
        policyCost = [policyCost; -1*Cost(i, CurrPolicy(i)+1)];
    end
    policyProb = policyProb - eye(stateSize);
    policyProb(:, stateSize) = -1*ones(stateSize,1);
    values = policyProb\policyCost;
    CurrCost = values(stateSize);
    values(stateSize) = 0;
    if (verbose)
        disp(transpose(values));
    end
    
    %Policy Improvement
    CurrPolicy = [];
    for i = 1:stateSize
        minCost = Inf;
        for j = 1:actionSize
            if (~isnan(Cost(i,j)))
                policyProb = TransProb(i, ((j-1)*stateSize+1):(j*stateSize));
                policyCost = Cost(i, j) + policyProb*values - values(i);
                if (minCost > policyCost)
                    minCost = policyCost;
                    minAct = j-1;
                end
            end
        end
        CurrPolicy = [CurrPolicy minAct];
    end
    
    %Check iteration
    if (checkCost)
        iterate = (LastCost ~= CurrCost);
    else
        iterate = sum(LastPolicy ~= CurrPolicy);
    end
end

%Get steady state
policyProb = [];
for i = 1:stateSize
    policyProb = [policyProb; TransProb(i,(CurrPolicy(i)*stateSize+1):((CurrPolicy(i)+1)*stateSize))];
end
policyProb = transpose(policyProb);
policyProb = policyProb - eye(stateSize);
policyProb(stateSize, :) = ones(1,stateSize);
policyCost = [zeros(stateSize-1,1); 1];
steadyState = transpose(policyProb\policyCost);

disp(CurrPolicy);
disp(CurrCost);
disp(steadyState);
